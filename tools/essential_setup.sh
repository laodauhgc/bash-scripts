#!/usr/bin/env bash
# ==============================================================================
# Ubuntu Development Environment Setup Script
# Optimized version with enhanced features and error handling
# ==============================================================================

set -euo pipefail

export DEBIAN_FRONTEND=noninteractive
export LANG=C.UTF-8

# ==== Script Configuration ====
readonly SCRIPT_VERSION="2.0.2"  # Updated version
readonly SCRIPT_NAME="$(basename "$0")"
readonly LOG_FILE="/tmp/${SCRIPT_NAME%.*}.log"
readonly LOCK_FILE="/tmp/${SCRIPT_NAME%.*}.lock"
readonly BACKUP_DIR="/tmp/setup_backup_$(date +%Y%m%d_%H%M%S)"

# ==== Colors and Formatting ====
if [[ -t 1 ]]; then
    readonly RED='\033[0;31m'
    readonly GREEN='\033[0;32m'
    readonly YELLOW='\033[1;33m'
    readonly BLUE='\033[0;34m'
    readonly PURPLE='\033[0;35m'
    readonly CYAN='\033[0;36m'
    readonly WHITE='\033[1;37m'
    readonly RESET='\033[0m'
    readonly BOLD='\033[1m'
else
    readonly RED='' GREEN='' YELLOW='' BLUE='' PURPLE='' CYAN='' WHITE='' RESET='' BOLD=''
fi

# ==== Logging Functions ====
log() { 
    local timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
    echo -e "${2:-$GREEN}[$timestamp] $1${RESET}" | tee -a "$LOG_FILE"
}

info()     { log "‚ÑπÔ∏è  $1" "$BLUE"; }
success()  { log "‚úÖ $1" "$GREEN"; }
warn()     { log "‚ö†Ô∏è  $1" "$YELLOW"; }
error()    { log "‚ùå $1" "$RED"; }
debug()    { [[ "${DEBUG:-0}" -eq 1 ]] && log "üêõ $1" "$PURPLE"; }
header()   { log "\n${BOLD}$1${RESET}" "$CYAN"; }

die() {
    error "$1"
    cleanup
    exit 1
}

# ==== Cleanup Function ====
cleanup() {
    debug "Cleaning up..."
    [[ -f "$LOCK_FILE" ]] && rm -f "$LOCK_FILE"
    trap - EXIT
}

# ==== Lock File Management ====
acquire_lock() {
    if [[ -f "$LOCK_FILE" ]]; then
        local pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            die "Script ƒëang ch·∫°y v·ªõi PID $pid. Vui l√≤ng ƒë·ª£i ho·∫∑c x√≥a file lock: $LOCK_FILE"
        else
            warn "T√¨m th·∫•y lock file c≈©, ƒëang x√≥a..."
            rm -f "$LOCK_FILE"
        fi
    fi
    echo $$ > "$LOCK_FILE"
    trap cleanup EXIT
}

# ==== Help Function ====
show_help() {
    cat << EOF
${BOLD}$SCRIPT_NAME v$SCRIPT_VERSION${RESET}
Ubuntu Development Environment Setup Script

${BOLD}USAGE:${RESET}
    $SCRIPT_NAME [OPTIONS]

${BOLD}OPTIONS:${RESET}
    -h, --help          Hi·ªÉn th·ªã help n√†y
    -v, --verbose       B·∫≠t ch·∫ø ƒë·ªô debug verbose
    -n, --dry-run       Ch·ªâ hi·ªÉn th·ªã nh·ªØng g√¨ s·∫Ω ƒë∆∞·ª£c c√†i ƒë·∫∑t
    -s, --skip-nodejs   B·ªè qua c√†i ƒë·∫∑t Node.js
    -u, --update-only   Ch·ªâ update h·ªá th·ªëng, kh√¥ng c√†i package m·ªõi
    --nodejs-version    Ch·ªâ ƒë·ªãnh version Node.js (m·∫∑c ƒë·ªãnh: lts)
    --backup            T·∫°o backup tr∆∞·ªõc khi thay ƒë·ªïi

${BOLD}EXAMPLES:${RESET}
    $SCRIPT_NAME                           # C√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh
    $SCRIPT_NAME --verbose --backup        # Verbose mode v·ªõi backup
    $SCRIPT_NAME --nodejs-version 18      # C√†i Node.js v18
    $SCRIPT_NAME --dry-run                 # Xem tr∆∞·ªõc nh·ªØng g√¨ s·∫Ω c√†i

EOF
}

# ==== Parse Arguments ====
DRY_RUN=0
SKIP_NODEJS=0
UPDATE_ONLY=0
CREATE_BACKUP=0
NODEJS_VERSION="lts"

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                DEBUG=1
                set -x
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=1
                info "üîç Ch·∫ø ƒë·ªô dry-run ƒë∆∞·ª£c b·∫≠t"
                shift
                ;;
            -s|--skip-nodejs)
                SKIP_NODEJS=1
                shift
                ;;
            -u|--update-only)
                UPDATE_ONLY=1
                shift
                ;;
            --nodejs-version)
                if [[ $# -lt 2 ]]; then
                    error "Option --nodejs-version requires a value"
                    exit 1
                fi
                NODEJS_VERSION="$2"
                shift 2
                ;;
            --backup)
                CREATE_BACKUP=1
                shift
                ;;
            *)
                error "T√πy ch·ªçn kh√¥ng h·ª£p l·ªá: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# ==== System Information ====
get_system_info() {
    info "üîç ƒêang thu th·∫≠p th√¥ng tin h·ªá th·ªëng..."
    
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        readonly OS_ID="$ID"
        readonly OS_NAME="$NAME"
        readonly OS_VERSION="$VERSION_ID"
    else
        die "Kh√¥ng th·ªÉ x√°c ƒë·ªãnh h·ªá ƒëi·ªÅu h√†nh!"
    fi

    readonly KERNEL_VERSION="$(uname -r)"
    readonly ARCHITECTURE="$(uname -m)"
    readonly TOTAL_RAM="$(free -h | awk '/^Mem:/ {print $2}')"
    readonly AVAILABLE_SPACE="$(df -h / | awk 'NR==2 {print $4}')"
    
    info "OS: $OS_NAME ($OS_VERSION)"
    info "Kernel: $KERNEL_VERSION"
    info "Architecture: $ARCHITECTURE"
    info "RAM: $TOTAL_RAM"
    info "Available space: $AVAILABLE_SPACE"
}

# ==== Root Check ====
check_root() {
    if [[ $EUID -ne 0 ]]; then
        die "‚ùå Script c·∫ßn quy·ªÅn root. Vui l√≤ng ch·∫°y: sudo $0"
    fi
    success "‚úÖ ƒêang ch·∫°y v·ªõi quy·ªÅn root"
}

# ==== Check Ubuntu Version ====
check_ubuntu_version() {
    if [[ "$OS_ID" != "ubuntu" ]]; then
        die "Script n√†y ch·ªâ h·ªó tr·ª£ Ubuntu. OS hi·ªán t·∫°i: $OS_NAME"
    fi
    
    local version_number=$(echo "$OS_VERSION" | cut -d. -f1)
    if [[ $version_number -lt 18 ]]; then
        die "Script y√™u c·∫ßu Ubuntu 18.04 tr·ªü l√™n. Version hi·ªán t·∫°i: $OS_VERSION"
    fi
    
    success "‚úÖ Ubuntu version h·ª£p l·ªá: $OS_VERSION"
}

# ==== Package Manager Setup ====
setup_package_manager() {
    if ! command -v apt >/dev/null 2>&1; then
        die "Kh√¥ng t√¨m th·∫•y apt package manager!"
    fi
    
    readonly PKG_MANAGER="apt"
    readonly UPDATE_CMD="apt update -qq"
    readonly INSTALL_CMD="apt install -y --no-install-recommends"
    readonly SEARCH_CMD="apt list --installed"
    
    success "‚úÖ Package manager: apt"
}

# ==== Enable Additional Repositories ====
enable_repositories() {
    header "üõ†Ô∏è K√≠ch ho·∫°t c√°c kho l∆∞u tr·ªØ c·∫ßn thi·∫øt"
    
    if [[ $DRY_RUN -eq 1 ]]; then
        info "DRY RUN: S·∫Ω k√≠ch ho·∫°t universe v√† multiverse repositories"
        return 0
    fi
    
    info "K√≠ch ho·∫°t universe repository..."
    add-apt-repository universe -y >/dev/null 2>&1 || warn "‚ö†Ô∏è Universe repository ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t"
    
    info "K√≠ch ho·∫°t multiverse repository..."
    add-apt-repository multiverse -y >/dev/null 2>&1 || warn "‚ö†Ô∏è Multiverse repository ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t"
    
    eval "$UPDATE_CMD" || die "‚ùå Kh√¥ng th·ªÉ update package list sau khi k√≠ch ho·∫°t repositories"
    
    success "‚úÖ C√°c kho l∆∞u tr·ªØ ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t"
}

# ==== Network Connectivity Check ====
check_network() {
    info "üåê Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng..."
    
    local test_urls=(
        "8.8.8.8"
        "google.com"
        "archive.ubuntu.com"
    )
    
    for url in "${test_urls[@]}"; do
        if ping -c 1 -W 5 "$url" >/dev/null 2>&1; then
            success "‚úÖ K·∫øt n·ªëi m·∫°ng OK"
            return 0
        fi
    done
    
    die "‚ùå Kh√¥ng c√≥ k·∫øt n·ªëi m·∫°ng!"
}

# ==== Backup Function ====
create_backup() {
    [[ $CREATE_BACKUP -eq 0 ]] && return 0
    
    info "üì¶ T·∫°o backup trong $BACKUP_DIR..."
    mkdir -p "$BACKUP_DIR"
    
    local backup_files=(
        "/etc/apt/sources.list"
        "/etc/environment"
        "/etc/profile"
        "${HOME}/.bashrc"
        "${HOME}/.profile"
    )
    
    for file in "${backup_files[@]}"; do
        if [[ -f "$file" ]]; then
            cp "$file" "$BACKUP_DIR/" 2>/dev/null || true
            debug "Backed up: $file"
        fi
    done
    
    success "‚úÖ Backup completed: $BACKUP_DIR"
}

# ==== Enhanced Package Lists ====
readonly CORE_PACKAGES=(
    # Build essentials
    "build-essential" "gcc" "g++" "make" "cmake" "autoconf" "automake" "libtool"
    
    # Development tools
    "git" "vim" "nano" "tree" "jq" "xmlstarlet"
    
    # Network tools
    "curl" "wget" "net-tools" "dnsutils" "traceroute" "nmap" "tcpdump" "netstat-nat"
    
    # System monitoring
    "htop" "iotop" "lsof" "strace" "sysstat" "ncdu"
    
    # Archive tools
    "zip" "unzip" "p7zip-full" "rar" "unrar"
    
    # Terminal multiplexers
    "tmux" "screen"
    
    # File sync and transfer
    "rsync"
    
    # Security and certificates
    "openssl" "ca-certificates" "gnupg" "software-properties-common"
    
    # Python ecosystem
    "python3" "python3-pip" "python3-venv" "python3-dev"
    
    # SSH and remote access
    "openssh-server" "openssh-client"
)

readonly OPTIONAL_PACKAGES=(
    # Additional development
    "docker.io" "docker-compose"
    
    # Database clients
    "mysql-client" "postgresql-client" "sqlite3"
    
    # Media tools
    "ffmpeg" "imagemagick"
    
    # Additional utilities
    "ranger" "fzf" "ripgrep" "fd-find"
)

# ==== Check Package Installation Status ====
is_package_installed() {
    local package="$1"
    dpkg -l "$package" 2>/dev/null | grep -q "^ii"
}

# ==== Get Packages to Install ====
get_packages_to_install() {
    local -n packages_ref=$1
    local -n result_ref=$2
    
    result_ref=()
    for package in "${packages_ref[@]}"; do
        if ! is_package_installed "$package"; then
            if apt-cache show "$package" >/dev/null 2>&1; then
                result_ref+=("$package")
            else
                warn "‚ö†Ô∏è Package $package kh√¥ng t·ªìn t·∫°i trong kho l∆∞u tr·ªØ, b·ªè qua..."
            fi
        else
            debug "Package already installed: $package"
        fi
    done
}

# ==== Install yq via pip3 ====
install_yq() {
    [[ $DRY_RUN -eq 1 ]] && return 0
    
    header "üì¶ C√†i ƒë·∫∑t yq qua pip3"
    
    if command -v yq >/dev/null 2>&1; then
        local current_version=$(yq --version 2>/dev/null || echo "unknown")
        warn "yq ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t: $current_version"
        return 0
    fi
    
    if [[ $DRY_RUN -eq 1 ]]; then
        info "DRY RUN: S·∫Ω c√†i ƒë·∫∑t yq qua pip3"
        return 0
    fi
    
    info "C√†i ƒë·∫∑t yq..."
    pip3 install yq || {
        error "‚ùå Kh√¥ng th·ªÉ c√†i ƒë·∫∑t yq qua pip3"
        return 1
    }
    
    success "‚úÖ yq ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t"
}

# ==== System Update ====
update_system() {
    header "üîÑ C·∫≠p nh·∫≠t h·ªá th·ªëng"
    
    if [[ $DRY_RUN -eq 1 ]]; then
        info "DRY RUN: S·∫Ω ch·∫°y apt update && apt upgrade"
        return 0
    fi
    
    info "Updating package lists..."
    eval "$UPDATE_CMD" || die "‚ùå Kh√¥ng th·ªÉ update package list"
    
    info "Upgrading installed packages..."
    apt upgrade -y || warn "‚ö†Ô∏è M·ªôt s·ªë packages kh√¥ng th·ªÉ upgrade"
    
    success "‚úÖ System update completed"
}

# ==== Install Packages ====
install_packages() {
    [[ $UPDATE_ONLY -eq 1 ]] && return 0
    
    header "üì¶ C√†i ƒë·∫∑t packages c·∫ßn thi·∫øt"
    
    local packages_to_install
    get_packages_to_install CORE_PACKAGES packages_to_install
    
    if [[ ${#packages_to_install[@]} -eq 0 ]]; then
        success "‚úÖ T·∫•t c·∫£ core packages ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t"
        return 0
    fi
    
    info "Packages c·∫ßn c√†i ƒë·∫∑t: ${#packages_to_install[@]} packages"
    info "Danh s√°ch: ${packages_to_install[*]}"
    debug "Package list: ${packages_to_install[*]}"
    
    if [[ $DRY_RUN -eq 1 ]]; then
        info "DRY RUN: S·∫Ω c√†i ƒë·∫∑t c√°c packages sau:"
        printf '  - %s\n' "${packages_to_install[@]}"
        return 0
    fi
    
    local batch_size=10
    local installed_count=0
    local failed_packages=()
    
    for ((i=0; i<${#packages_to_install[@]}; i+=batch_size)); do
        local batch=("${packages_to_install[@]:i:batch_size}")
        info "Installing batch $((i/batch_size + 1)): ${batch[*]}"
        
        if timeout 300 eval "$INSTALL_CMD ${batch[*]}"; then
            installed_count=$((installed_count + ${#batch[@]}))
            success "‚úÖ Batch installed successfully"
        else
            warn "‚ö†Ô∏è Batch installation failed, trying individual packages..."
            for package in "${batch[@]}"; do
                if timeout 300 eval "$INSTALL_CMD $package"; then
                    installed_count=$((installed_count + 1))
                    debug "‚úÖ $package installed"
                else
                    failed_packages+=("$package")
                    error "‚ùå Failed to install: $package"
                fi
            done
        fi
    done
    
    success "‚úÖ Installed $installed_count/${#packages_to_install[@]} packages"
    
    if [[ ${#failed_packages[@]} -gt 0 ]]; then
        warn "‚ö†Ô∏è Failed packages: ${failed_packages[*]}"
        warn "Vui l√≤ng ki·ªÉm tra v√† c√†i ƒë·∫∑t th·ªß c√¥ng c√°c package tr√™n n·∫øu c·∫ßn."
    fi
}

# ==== Node.js Installation ====
install_nodejs() {
    [[ $SKIP_NODEJS -eq 1 ]] && return 0
    
    header "üì¶ C√†i ƒë·∫∑t Node.js v√† npm"
    
    if command -v node >/dev/null 2>&1 && command -v npm >/dev/null 2>&1; then
        local current_version=$(node --version 2>/dev/null || echo "unknown")
        warn "Node.js ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t: $current_version"
        return 0
    fi
    
    if [[ $DRY_RUN -eq 1 ]]; then
        info "DRY RUN: S·∫Ω c√†i ƒë·∫∑t Node.js version $NODEJS_VERSION"
        return 0
    fi
    
    info "C√†i ƒë·∫∑t Node.js $NODEJS_VERSION..."
    
    if [[ "$NODEJS_VERSION" != "system" ]]; then
        info "Adding NodeSource repository..."
        curl -fsSL https://deb.nodesource.com/setup_${NODEJS_VERSION}.x | bash - || {
            warn "‚ö†Ô∏è Kh√¥ng th·ªÉ th√™m NodeSource repo, c√†i ƒë·∫∑t t·ª´ Ubuntu repo..."
            timeout 300 eval "$INSTALL_CMD nodejs npm" || error "‚ùå Failed to install nodejs npm"
        }
        timeout 300 eval "$INSTALL_CMD nodejs" || error "‚ùå Failed to install nodejs"
    else
        timeout 300 eval "$INSTALL_CMD nodejs npm" || error "‚ùå Failed to install nodejs npm"
    fi
    
    if command -v node >/dev/null 2>&1 && command -v npm >/dev/null 2>&1; then
        local node_version=$(node --version)
        local npm_version=$(npm --version)
        success "‚úÖ Node.js $node_version v√† npm $npm_version ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t"
        
        info "Configuring npm global directory..."
        mkdir -p /usr/local/lib/node_modules
        npm config set prefix /usr/local
    else
        error "‚ùå Node.js installation failed"
    fi
}

# ==== System Optimization ====
optimize_system() {
    header "‚ö° T·ªëi ∆∞u h√≥a h·ªá th·ªëng"
    
    if [[ $DRY_RUN -eq 1 ]]; then
        info "DRY RUN: S·∫Ω th·ª±c hi·ªán t·ªëi ∆∞u h√≥a h·ªá th·ªëng"
        return 0
    fi
    
    info "Cleaning package cache..."
    apt autoremove -y >/dev/null 2>&1 || true
    apt autoclean >/dev/null 2>&1 || true
    
    if command -v updatedb >/dev/null 2>&1; then
        info "Updating locate database..."
        updatedb &
    fi
    
    success "‚úÖ System optimization completed"
}

# ==== Generate Summary Report ====
generate_report() {
    header "üìã B√°o c√°o c√†i ƒë·∫∑t"
    
    local report_file="/tmp/setup_report_$(date +%Y%m%d_%H%M%S).txt"
    
    {
        echo "Ubuntu Setup Script - Installation Report"
        echo "========================================"
        echo "Date: $(date)"
        echo "Script Version: $SCRIPT_VERSION"
        echo "System: $OS_NAME $OS_VERSION"
        echo "Kernel: $KERNEL_VERSION"
        echo "Architecture: $ARCHITECTURE"
        echo ""
        
        echo "Installed Software Versions:"
        echo "----------------------------"
        command -v git >/dev/null && echo "Git: $(git --version)"
        command -v python3 >/dev/null && echo "Python: $(python3 --version)"
        command -v yq >/dev/null && echo "yq: $(yq --version)"
        command -v node >/dev/null && echo "Node.js: $(node --version)"
        command -v npm >/dev/null && echo "npm: $(npm --version)"
        command -v docker >/dev/null && echo "Docker: $(docker --version)"
        
        echo ""
        echo "Log file: $LOG_FILE"
        [[ $CREATE_BACKUP -eq 1 ]] && echo "Backup: $BACKUP_DIR"
        
    } | tee "$report_file"
    
    info "üìÑ Report saved: $report_file"
}

# ==== Post-installation Setup ====
post_installation_setup() {
    header "üîß Thi·∫øt l·∫≠p sau c√†i ƒë·∫∑t"
    
    if [[ $DRY_RUN -eq 1 ]]; then
        info "DRY RUN: S·∫Ω th·ª±c hi·ªán post-installation setup"
        return 0
    fi
    
    if systemctl is-available ssh >/dev/null 2>&1; then
        systemctl enable ssh >/dev/null 2>&1 || true
        info "‚úÖ SSH service enabled"
    fi
    
    if command -v ufw >/dev/null 2>&1; then
        info "Setting up basic firewall rules..."
        ufw --force enable >/dev/null 2>&1 || true
        ufw allow ssh >/dev/null 2>&1 || true
    fi
    
    success "‚úÖ Post-installation setup completed"
}

# ==== Main Function ====
main() {
    acquire_lock
    parse_args "$@"
    
    cat << EOF
${BOLD}${CYAN}
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                Ubuntu Setup Script v$SCRIPT_VERSION                ‚ïë
‚ïë            Professional Development Environment          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
${RESET}
EOF
    
    info "üöÄ Starting Ubuntu setup process..."
    info "üìù Log file: $LOG_FILE"
    
    check_root
    get_system_info
    check_ubuntu_version
    setup_package_manager
    enable_repositories
    check_network
    create_backup
    update_system
    install_packages
    install_yq
    install_nodejs
    optimize_system
    post_installation_setup
    generate_report
    
    header "üéâ HO√ÄN TH√ÄNH!"
    success "‚úÖ Ubuntu development environment ƒë√£ ƒë∆∞·ª£c setup th√†nh c√¥ng!"
    info "üìù Vui l√≤ng ch·∫°y 'source ~/.bashrc' ho·∫∑c m·ªü terminal m·ªõi"
    info "üìÑ Xem report chi ti·∫øt t·∫°i: /tmp/setup_report_*.txt"
    
    [[ $CREATE_BACKUP -eq 1 ]] && info "üíæ Backup files: $BACKUP_DIR"
}

# ==== Script Entry Point ====
if [[ "${BASH_SOURCE[0]:-$0}" == "${0}" ]]; then
    main "$@"
fi
